★ 1. cat
    ▶ cat 命令用于连接文件并打印到标准输出设备上。

    参数说明：
    -n 或 --number：由 1 开始对所有输出的行数编号。
    -b 或 --number-nonblank：和 -n 相似，只不过对于空白行不编号。
    -s 或 --squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。
    -v 或 --show-nonprinting：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。
    -E 或 --show-ends : 在每行结束处显示 $。
    -T 或 --show-tabs: 将 TAB 字符显示为 ^I。
    -e : 等价于 -vE。
    -A, --show-all：等价于 -vET。
    -e：等价于"-vE"选项；
    -t：等价于"-vT"选项；

    ◆ 实例：
        把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：
        $ cat -n textfile1 > textfile2

        把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：
        $ cat -b textfile1 textfile2 >> textfile3

        清空 /etc/test.txt 文档内容：
        $ cat /dev/null > /etc/test.txt

★ 2. chattr
    ▶ chattr命令用于改变文件属性。

    这项指令可改变存放在ext2文件系统上的文件或目录属性，这些属性共有以下8种模式：
      参数说明：
        a：让文件或目录仅供附加用途。
        b：不更新文件或目录的最后存取时间。
        c：将文件或目录压缩后存放。
        d：将文件或目录排除在倾倒操作之外。
        i：不得任意更动文件或目录。
        s：保密性删除文件或目录。
        S：即时更新文件或目录。
        u：预防意外删除。

      参数
    　　-R 递归处理，将指定目录下的所有文件及子目录一并处理。
    　　-v<版本编号> 设置文件或目录版本。
    　　-V 显示指令执行过程。
    　　+<属性> 开启文件或目录的该项属性。
    　　-<属性> 关闭文件或目录的该项属性。
    　　=<属性> 指定文件或目录的该项属性。

    ◆ 实例：
        防止某个文件被修改后
        $ chattr +i test.txt

        让某个文件只能添加不能删除
        $ chattr +a test.txt

★ 3. chgrp
    ▶ Linux chgrp命令用于变更文件或目录的所属群组。
      在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。

    语法
    chgrp [-cfhRv][--help][--version][所属群组][文件或目录...] 或 chgrp [-cfhRv][--help][--reference=<参考文件或目录>][--version][文件或目录...]

    参数说明
    　　-c或--changes 效果类似"-v"参数，但仅回报更改的部分。
    　　-f或--quiet或--silent 　不显示错误信息。
    　　-h或--no-dereference 　只对符号连接的文件作修改，而不更动其他任何相关文件。
    　　-R或--recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。
    　　-v或--verbose 　显示指令执行过程。
    　　--help 　在线帮助。
    　　--reference=<参考文件或目录> 　把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。
    　　--version 　显示版本信息。

    ◆ 实例：
        改变文件的群组属性,把test.log所属组改为bin
        $ chgrp -v bin test.log

        实例2：根据指定文件改变文件的群组属性，即将某个文件的分组改成与另一个文件的分组一致（将test.log的分组改为与test2.log的分组一致）
        $ chgrp --reference=test2.log test.log

★ 4. chmod
      ▶ Linux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。

      语法
      chmod [-cfvR] [--help] [--version] mode file...

      ■ 参数说明
      mode : 权限设定字串，格式如下 :
      [ugoa...][[+-=][rwxX]...][,...]

      其中：
      u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。
      + 表示增加权限、- 表示取消权限、= 表示唯一设定权限。
      r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。

      其他参数说明：
      -c : 若该文件权限确实已经更改，才显示其更改动作
      -f : 若该文件权限无法被更改也不要显示错误讯息
      -v : 显示权限变更的详细资料
      -R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)
      --help : 显示辅助说明
      --version : 显示版本

      ◆ 实例：
        将文件 test.txt 设为所有人皆可读取 :
        $ chmod ugo+r test.txt    /   chmod a+r test.txt   /   chmod 444 test.txt

        将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :
        $ chmod ug+w,o-w file1.txt file2.txt

        将 ex1.py 设定为只有该文件拥有者可以执行 :
        $ chmod u+x,g-x,o-x ex1.py

        将目前目录下的所有文件与子目录皆设为任何人可读取 :
        $ chmod -R a+r *

        $ chmod a=rwx file   等价于    chmod 777 file
        $ chmod ug=rwx,o=x file   等价于    chmod 771 file

★ 5. chwon
    ▶ Linux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。
      一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限可以自己的文件拥有者改设为别人。只有系统管理者(root)才有这样的权限。

    语法    --chown [选项]... [所有者][:[组]] 文件...
    chown [-cfhvR] [--help] [--version] user[:group] file...

    参数 :
    user : 新的文件拥有者的使用者 ID
    group : 新的文件拥有者的使用者群体(group)
    -c : 若该文件拥有者确实已经更改，才显示其更改动作
    -f : 若该文件拥有者无法被更改也不要显示错误讯息
    -h : 只对于连结(link)进行变更，而非该 link 真正指向的文件
    -v : 显示拥有者变更的详细资料
    -R : 对目前目录下的所有文件与子目录进行相同的拥有者变更(即以递回的方式逐个变更)
    --help : 显示辅助说明
    --version : 显示版本

    ◆ 实例：
        修改file文件的所有者为lxy?
        $ chown lxy file

        修改file文件的用户组为lxy？
        $ chown :lxy file

        同时修改文件的所有者和用户组为lxy的拥有者和lxy的群组？
        $ chown lxy:lxy file

        同时修改文件夹和其子文件的所属用户组和所有者为lxy拥有者和lxy组。
        $ chown -R lxy:lxy *

★ 6. cksum
    ▶ Linux cksum命令用于检查文件的CRC是否正确。确保文件从一个系统传输到另一个系统的过程中不被损坏。
      CRC是一种排错检查方式，该校验法的标准由CCITT所指定，至少可检测到99.998%的已知错误。
      指定文件交由指令"cksum"进行校验后，该指令会返回校验结果供用户核对文件是否正确无误。若不指定任何文件名称或是所给予的文件名为"-"，则指令"cksum"会从标准输入设备中读取数据。

    语法
    cksum [--help][--version][文件...]

     ◆ 实例：
        $ cksum testfile     --1263453430 78 testfile1         //输出信息 
                               上面的输出信息中，"1263453430"表示校验码，"78"表示字节数。
                               注意：如果文件中有任何字符被修改，都将改变计算后CRC校验码的值。

★ 7. cmp
    ▶ Linux cmp命令用于比较两个文件是否有差异。
    当相互比较的两个文件完全一样时，则该指令不会显示任何信息。
    若发现有所差异，预设会标示出第一个不同之处的字符和列数编号。若不指定任何文件名称或是所给予的文件名为"-"，则cmp指令会从标准输入设备读取数据。

    参数：
    -c或--print-chars 　除了标明差异处的十进制字码之外，一并显示该字符所对应字符。
    -i<字符数目>或--ignore-initial=<字符数目> 　指定一个数目。
    -l或--verbose 　标示出所有不一样的地方。
    -s或--quiet或--silent 　不显示错误信息。
    -v或--version 　显示版本信息。
    --help 　在线帮助。

    ◆ 实例：
       $ cmp file1 file2

★ 8. diff
    ▶ Linux diff命令用于比较文件的差异。
      diff以逐行的方式，比较文本文件的异同处。如果指定要比较目录，则diff会比较目录中相同文件名的文件，但不会比较其中子目录。

     ◆ 实例：
       $ diff test1 test2
       $ diff -c test1 test2
       $ diff test1 test2 | diffstat   --没看懂

★ 9.file
    ▶ Linux file命令用于辨识文件类型。
      通过file指令，我们得以辨识该文件的类型。

    参数：
    -b 　列出辨识结果时，不显示文件名称。
    -c 　详细显示指令执行过程，便于排错或分析程序执行的情形。
    -f<名称文件> 　指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。
    -L 　直接显示符号连接所指向的文件的类别。
    -m<魔法数字文件> 　指定魔法数字文件。
    -v 　显示版本信息。
    -z 　尝试去解读压缩文件的内容。
    [文件或目录...] 要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。

     ◆ 实例：
           $ file test1

★ 10.find
    ▶ Linux find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。
      如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。

    语法
    find   path   -option   [   -print ]   [ -exec   -ok   command ]   {} \ ;

    参数说明 :

    find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。

    expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。
    -mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件
    -amin n : 在过去 n 分钟内被读取过
    -anewer file : 比文件 file 更晚被读取过的文件
    -atime n : 在过去 n 天过读取过的文件
    -cmin n : 在过去 n 分钟内被修改过
    -cnewer file :比文件 file 更新的文件
    -ctime n : 在过去 n 天过修改过的文件
    -empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name
    -ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写
    -name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写
    -size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。
    -type c : 文件类型是 c 的文件。

    d: 目录
    c: 字型装置文件
    b: 区块装置文件
    p: 具名贮列
    f: 一般文件
    l: 符号连结
    s: socket
    -pid n : process id 是 n 的文件

    ◆ 实例
        将目前目录及其子目录下所有延伸档名是 php 的文件列出来?
        $ find ./ -[i]name  "*.php"

        将目前目录其其下子目录中所有一般文件列出?
        $ find ./ -type f

        将目前目录及其子目录下所有最近 20 天内更新过的文件列出?
        $ find ./ -ctime -20

        将目前目录及其子目录下所有最近 20 天内读取过的文件列出?
        $ find ./ -atime -20

        将目前目录及其子目录下所有最近 20 分组内更新过的文件列出?
        $ find ./ -cmin -20

        将目前目录及其子目录下所有最近 20 分组内读取过的文件列出?
        $ find ./ -amin -20

        将当前目录中比指定文件a.txt更晚更新的文件? (比如我最先新建了a.txt，那么就列出除了a.txt之后的全部文件)
        $ find ./ -cnewer a.txt

        将当前目录中比指定文件a.txt最晚读取的文件?
        $ find ./ -anewer a.txt

        将当前的文件全部空文件列出?
        $ find ./ -empty

        查找/var/logs目录中更改时间在7日以前的普通文件，并在删除之前询问它们?
        $ find /var/logs -type f -mtime +7 -ok rm { }

        查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件：

        $ find . -type f -perm 644 -exec ls -l { } ;
        为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径：

        $ find / -type f -size 0 -exec ls -l { } ;
        查找/var/logs目录中更改时间在7日以前的普通文件，并在删除之前询问它们:

        $ find /var/logs -type f -mtime +7 -ok rm { } ;

★ 10.ln
    ▶ Linux ln命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。
    当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间.

    语法
     ln [参数][源文件或目录][目标文件或目录]

    硬链接： 与普通文件没什么不同，inode 都指向同一个文件在硬盘中的区块. -- ln myfile hard
    软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径。 -- ln -s  myfile soft

    命令功能 :
    Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 :
        硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称;
        而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。
    不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。

    软链接：
    1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式
    2.软链接可以 跨文件系统 ，硬链接不可以
    3.软链接可以对一个不存在的文件名进行链接
    4.软链接可以对目录进行链接

    硬链接：
    1.硬链接，以文件副本的形式存在。但不占用实际空间。
    2.不允许给目录创建硬链接
    3.硬链接只有在同一个文件系统中才能创建

    ◆ 实例
        给test.log创建软连接？
        $ ln -s test.log my_soft_ln

        给test.log创建硬链接？
        $ ln test.log my_hard_ln

★ 11.locate
    Linux locate命令用于查找符合条件的文档，他会去保存文档和目录名称的数据库内，查找合乎范本样式条件的文档或目录。
    一般情况我们只需要输入 locate your_file_name 即可查找指定文件。

★ 12.mv
    Linux mv命令用来为文件或目录改名、或将文件或目录移入其它位置。
    ◆ 实例
        将文件 aaa 更名为 bbb :
        $ mv aaa bbb

        将info目录放入logs目录中。注意，如果logs目录不存在，则该命令将info改名为logs。
        $ mv info/ logs

        再如将/usr/student下的所有文件和目录移到当前目录下，命令行为：
        $ mv /usr/student/*  .

★ 13.rm
    Linux rm命令用于删除一个文件或者目录。

    语法
        rm [options] name...
    参数：
        -i 删除前逐一询问确认。
        -f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。
        -r 将目录及以下之档案亦逐一删除。
    实例
        删除文件可以直接使用rm命令，若删除目录则必须配合选项"-r"，例如：
        $ rm  test.txt

        rm：是否删除 一般文件 "test.txt"? y
        $ rm  homework

        rm: 无法删除目录"homework": 是一个目录
        $ rm  -r  homework

        rm：是否删除 目录 "homework"? y

        删除当前目录下的所有文件及目录，命令行为：
        $ rm  -r  *

★ 14.split
    Linux split命令用于将一个文件分割成数个。
    该指令将大文件分割成较小的文件，在默认情况下将按照每1000行切割成一个小文件。

    语法
        split [--help][--version][-<行数>][-b <字节>][-C <字节>][-l <行数>][要切割的文件][输出文件名]

    参数说明：
        -<行数> : 指定每多少行切成一个小文件
        -b<字节> : 指定每多少字节切成一个小文件
        --help : 在线帮助
        --version : 显示版本信息
        -C<字节> : 与参数"-b"相似，但是在切 割时将尽量维持每行的完整性
        [输出文件名] : 设置切割后文件的前置文件名， split会自动在前置文件名后再加上编号

    实例
        使用指令"split"将文件"README"每6行切割成一个文件，输入如下命令：

        $ split -6 README       #将README文件每六行分割成一个文件
        以上命令执行后，指令"split"会将原来的大文件"README"切割成多个以"x"开头的小文件。而在这些小文件中，每个文件都只有6行内容。

        使用指令"ls"查看当前目录结构，如下所示：

        $ ls                                #执行ls指令
        #获得当前目录结构
        README xaa xad xag xab xae xah xac xaf xai


★ 15.tee
    Linux tee命令用于读取标准输入的数据，并将其内容输出成文件。
    tee指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件。

    语法
        tee [-ai][--help][--version][文件...]

    参数：
        -a或--append 　附加到既有文件的后面，而非覆盖它．
        -i或--ignore-interrupts 　忽略中断信号。
        --help 　在线帮助。
        --version 　显示版本信息。

    实例
        使用指令"tee"将用户输入的数据同时保存到文件"file1"和"file2"中，输入如下命令：
        $ tee file1 file2                   #在两个文件中复制内容

        以上命令执行后，将提示用户输入需要保存到文件的数据，如下所示：

        My Linux                        #提示用户输入数据
        My Linux                        #输出数据，进行输出反馈
        此时，可以分别打开文件"file1"和"file2"，查看其内容是否均是"My Linux"即可判断指令"tee"是否执行成功。


★ 16.touch
    Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。
    ls -l 可以显示档案的时间记录。

    语法
        touch [-acfm][-d<日期时间>][-r<参考文件或目录>] [-t<日期时间>][--help][--version][文件或目录…]

    参数说明：
        a 改变档案的读取时间记录。
        m 改变档案的修改时间记录。
        c 假如目的档案不存在，不会建立新的档案。与 --no-create 的效果一样。
        f 不使用，是为了与其他 unix 系统的相容性而保留。
        r 使用参考档的时间记录，与 --file 的效果一样。
        d 设定时间与日期，可以使用各种不同的格式。
        t 设定档案的时间记录，格式与 date 指令相同。
        --no-create 不会建立新档案。
        --help 列出指令格式。
        --version 列出版本讯息。
    实例
        使用指令"touch"修改文件"testfile"的时间属性为当前系统时间，输入如下命令：
        $ touch testfile                #修改文件的时间属性


        使用指令"touch"时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件"file"，输入如下命令：
        $ touch file            #创建一个名为“file”的新的空白文件

★ 17.cp
    Linux cp命令主要用于复制文件或目录。

    语法
        cp [options] source dest

    参数说明：
        -a ：此选项在复制目录时使用，它保留链接，文件属性，并复制目录下的所有内容。其作用等于dpr组合。
        -d ：复制时保留链接。这里说的连接相当于windows的快捷方式。
        -f ：覆盖已存在的目标文件而不提示。
        -i ：与-f相反，在覆盖文件之前给出提示，要求用户输入'y'确认覆盖。
        -p ：除了复制文件内容，把文件权限和修改时间也一并复制。
        -r ：复制文件及其子目录和文件的内容。
        -l ：不复制文件，只生产链接。（如果修改链接，则会直接反馈到源文件上）

    实例：
        使用指令"cp"将当前目录"test/"下的所有文件复制到新目录"newtest"下
        $ cp -r test newtest

★ 18.rhmask
    Linux rhmask命令用于对文件进行加密和解密操作。
    执行rhmask指令可制作加密过的文件，方便用户在公开的网络上传输该文件，而不至于被任意盗用。

    语法
        rhmask [加密文件][输出文件] 或 rhmask [-d][加密文件][源文件][输出文件]

    参数：
        -d 　产生加密过的文件。

    实例
        使用指令"rhmask"将加密文件"code.txt"进行加密后，另存为输出文件"demo.txt"，输入如下命令：
        $ rhmask code.txt demo.txt



